'copyright (C) Kroc Camen 2018, BSD 2-clause

'   Engines_Enumerate()
'   Engines_KinValue%(kin$*1)   -> INTEGER
'   Engines_Filter()
'   Engines_Select(engine%)
'   Engines_GetType%(type$)     -> INTEGER

'walk the ports folder and identify all engines present
'=============================================================================
SUB Engines_Enumerate()
    'loop counter
    DIM i AS _UNSIGNED LONG
    
    LET Engines_Count = 0
    
    'create a directory list in a file, containing only sub-folder names
    CHDIR DIR_EXE$ + "ports"
    SHELL _HIDE "DIR /AD /B > dir.tmp"
    
    DIM dir_handle%
    LET dir_handle% = FREEFILE
    OPEN "dir.tmp" FOR INPUT AS #dir_handle%
    
    DO WHILE EOF(dir_handle%) = FALSE
        'read a folder-name
        DIM dir$
        LINE INPUT #dir_handle%, dir$
        
        'check for an INI file in the engine's folder
        DIM ini_path$
        LET ini_path$ = _CWD$ + "\" + dir$ + "\porta-doom.ini"
        IF NOT _FILEEXISTS(ini_path$) THEN GOTO NextFolder
        
        'read the global values
        DIM ini_engine$
        LET ini_engine$ = ReadSetting$(ini_path$, "global", "engine")
        DIM ini_tier$
        LET ini_tier$ = ReadSetting$(ini_path$, "global", "tier")
        DIM ini_rank$
        LET ini_rank$ = ReadSetting$(ini_path$, "global", "rank")
        
        DIM ini_index%
        LET ini_index% = 1
        DO
            DIM ini_id$
            LET ini_id$ = ReadSetting$("", "engines", STRINT$(ini_index%))
            IF ini_id$ = "" THEN EXIT DO
            
            'read engine data from the INI file
            DIM ini_section$
            LET ini_section$ = "engine." + ini_id$
            
            'if this is a 32-bit machine, we can immediately
            'throw away any 64-bit engines:
            
            'read the engine's CPU-type
            DIM ini_bit$
            LET ini_bit$ = ReadSetting$("", ini_section$, "bit")
            
            'executable architecture must be either 32 or 64-bit
            IF ini_bit$ <> "32" AND ini_bit$ <> "64" THEN
                'TODO: output warning?
                'default to 32-bit
                LET ini_bit$ = "32"
            END IF
            
            'if this is a 32-bit machine,
            '(or the `/32` switch was used)
            IF CPU_BIT = 32 THEN
                'if the engine is 64-bit, skip it entirely
                '-- it wouldn't run on this CPU
                IF ini_bit$ = "64" THEN GOTO NextEngine
            END IF
            
            DIM ini_title$
            LET ini_title$ = ReadSetting$("", ini_section$, "title")
            DIM ini_type$
            LET ini_type$ = ReadSetting$("", ini_section$, "type")
            DIM ini_exe$
            LET ini_exe$ = ReadSetting$("", ini_section$, "exe")
            DIM ini_ver$
            LET ini_ver$ = ReadSetting$("", ini_section$, "ver")
            DIM ini_vid$
            LET ini_vid$ = ReadSetting$("", ini_section$, "vid")
            DIM ini_kin$
            LET ini_kin$ = ReadSetting$("", ini_section$, "kin")
            DIM ini_cfg$
            LET ini_cfg$ = ReadSetting$("", ini_section$, "cfg")
            DIM ini_save$
            LET ini_save$ = ReadSetting$("", ini_section$, "save")
            DIM ini_tags$
            LET ini_tags$ = ReadSetting$("", ini_section$, "tags")
            DIM ini_auto$
            LET ini_auto$ = ReadSetting$("", ini_section$, "auto")
            DIM ini_cmd$
            LET ini_cmd$ = ReadSetting$("", ini_section$, "cmd")
            
            'process the tag list
            CALL Tags_Add(ini_tags$)
            
            'increase the list of known engines
            LET Engines_Count = Engines_Count + 1
            REDIM _PRESERVE Engines(1 TO Engines_Count) AS Engine
            
            LET Engines(Engines_Count).engine = STRADD&(LCASE$(ini_engine$))
            LET Engines(Engines_Count).id = STRADD&(LCASE$(ini_id$))
            
            LET Engines(Engines_Count).dir = STRADD&(dir$)
            
            SELECT CASE LCASE$(ini_tier$)
                CASE "high": LET Engines(Engines_Count).tier = TIER_HIGH
                CASE "medium": LET Engines(Engines_Count).tier = TIER_MEDIUM
                CASE "low": LET Engines(Engines_Count).tier = TIER_LOW
                'TODO: none of the above?
            END SELECT
            
            LET Engines(Engines_Count).rank = VAL(ini_rank$)
            LET Engines(Engines_Count).title = STRADD&(ini_title$)
            
            LET Engines(Engines_Count).type = Engines_GetType%(ini_type$)
            
            LET Engines(Engines_Count).exe = STRADD&(ini_exe$)
            LET Engines(Engines_Count).ver = VAL(ini_ver$)
            LET Engines(Engines_Count).bit = VAL(ini_bit$)
            LET Engines(Engines_Count).vid = VAL(ini_vid$)
            SELECT CASE UCASE$(ini_kin$)
                CASE "X": LET Engines(Engines_Count).kin = KIN_X
                CASE "V": LET Engines(Engines_Count).kin = KIN_V
                CASE "B": LET Engines(Engines_Count).kin = KIN_B
                CASE "Z": LET Engines(Engines_Count).kin = KIN_Z
                CASE "G": LET Engines(Engines_Count).kin = KIN_G
                CASE ELSE
                    LET Engines(Engines_Count).kin = 0
            END SELECT
            LET Engines(Engines_Count).cfg = STRADD&(ini_cfg$)
            LET Engines(Engines_Count).save = STRADD&(ini_save$)
            LET Engines(Engines_Count).tags = STRADD&(ini_tags$)
            LET Engines(Engines_Count).auto = STRADD&(ini_auto$)
            LET Engines(Engines_Count).cmd = STRADD&(ini_cmd$)
            
            NextEngine:
            LET ini_index% = ini_index% + 1
        LOOP
    NextFolder:
    LOOP
    
    CLOSE #dir_handle%
    KILL "dir.tmp"
    CHDIR DIR_EXE$
    
    'prioritise engine list:
    '-------------------------------------------------------------------------
    '... given ten different versions of GZDoom, each with hardware/software
    'renderers, which is the 'best' that we should default to?
    
    'the criteria for the 'best' engine is:
    '- prefer engines in higher tiers, i.e. "high" > "medium" > "low"
    '- prefer engines with a higher rank
    '- prefer engines in a higher genealogy, i.e. "G" > "Z" > "B" > "V"
    '- prefer newer versions over older versions
    '- prefer hardware renderers (if present) over software
    '- prefer 64-bit (if present and machine supports it) over 32-bit
    
    'to whit, re-order the list of engines according to this criteria:
    
    DIM sorted%
    LET sorted% = FALSE
    DIM sortCount%
    
    DO WHILE sorted% = FALSE
        LET sorted% = TRUE
        
        FOR i = 2 TO Engines_Count
            'compare the engine with the one above
            '(A = above, B = below)
            DIM A%, B%
            LET A% = i - 1
            LET B% = i
            
            'compare the engine's tier:
            DIM tA%, tB%
            LET tA% = Engines(A%).tier
            LET tB% = Engines(B%).tier
            
            'if the engine below is of a higher tier, move it up
            IF tB% > tA% THEN
                SWAP Engines(A%), Engines(B%)
                LET sortCount% = sortCount% + 1
                LET sorted% = FALSE
            
            ELSEIF tB% = tA% THEN
                'compare the engine's rank:
                DIM rA%, rB%
                LET rA% = Engines(A%).rank
                LET rB% = Engines(B%).rank
                
                'if the engine below is of a higher rank, move it up
                IF rB% > rA% THEN
                    SWAP Engines(A%), Engines(B%)
                    LET sortCount% = sortCount% + 1
                    LET sorted% = FALSE
                    
                ELSEIF rB% = rA% THEN
                    'compare the two engine's genealogy:
                    DIM kA%, kB%
                    LET kA% = Engines(A%).kin
                    LET kB% = Engines(B%).kin
                    
                    'if the engine below is of a higher genealogy, move it up
                    IF kB% > kA% THEN
                        SWAP Engines(A%), Engines(B%)
                        LET sortCount% = sortCount% + 1
                        LET sorted% = FALSE
                    
                    ELSEIF kB% = kA% THEN
                        'compare the names (alphabetically sort engines)
                        DIM nA$, nB$
                        LET nA$ = STRGET$(Engines(A%).engine)
                        LET nB$ = STRGET$(Engines(B%).engine)
                        
                        IF nB$ < nA$ THEN
                            SWAP Engines(A%), Engines(B%)
                            LET sortCount% = sortCount% + 1
                            LET sorted% = FALSE
                        
                        ELSEIF nB$ = nA$ THEN
                            'compare the two engine's version numbers
                            DIM vA%, vB%
                            LET vA% = Engines(A%).ver
                            LET vB% = Engines(B%).ver
                            
                            IF vB% > vA% THEN
                                SWAP Engines(A%), Engines(B%)
                                LET sortCount% = sortCount% + 1
                                LET sorted% = FALSE
                                
                            ELSEIF vB% = vA% THEN
                                'compare renderer colour-depth
                                DIM cA%, cB%
                                LET cA% = Engines(A%).vid
                                LET cB% = Engines(B%).vid
                                
                                IF cB% > cA% THEN
                                    SWAP Engines(A%), Engines(B%)
                                    LET sortCount% = sortCount% + 1
                                    LET sorted% = FALSE
                                
                                ELSEIF cB% = cA% THEN
                                    'compare executable CPU-type (32/64-bit)
                                    DIM xA%, xB%
                                    LET xA% = Engines(A%).bit
                                    LET xB% = Engines(B%).bit
                                    
                                    IF xB% > xA% THEN
                                        SWAP Engines(A%), Engines(B%)
                                        LET sortCount% = sortCount% + 1
                                        LET sorted% = FALSE
                                    END IF
                                END IF
                                
                            END IF
                        END IF
                    END IF
                END IF
            END IF
        NEXT i
    LOOP
    
    ''PRINT "SORT COUNT: " + STRINT$(sortCount%)
    ''PRINT ""
    ''SLEEP
    
    '-------------------------------------------------------------------------
    
    'create a look-up table of which engines provide which tags
    REDIM EngineTags(1 TO Engines_Count, 0 TO UBOUND(Tags)) AS LONG
    FOR i = 1 TO UBOUND(Engines)
        LET tag$ = Tags_Split$(STRGET$(Engines(i).tags))
        DO WHILE tag$ <> ""
            'find the tag index
            LET tag% = Tags_Find%(tag$)
            'set up the game <> tag mapping
            LET EngineTags(i, tag%) = 1
            'get the next tag in the list
            LET tag$ = Tags_Split$("")
        LOOP
    NEXT i
    
    'also, do this for game definitions -- this has to be done after
    'enumerating the engines, as all unique tags will be known by then
    REDIM GameTags(1 TO Games_Count, 1 TO UBOUND(Tags)) AS LONG
    FOR i = 1 TO UBOUND(Games)
        LET tag$ = Tags_Split$(STRGET$(Games(i).tags))
        DO WHILE tag$ <> ""
            'find the tag index
            LET tag% = Tags_Find%(tag$)
            'set up the game <> tag mapping
            LET GameTags(i, tag%) = 1
            'get the next tag in the list
            LET tag$ = Tags_Split$("")
        LOOP
    NEXT i
    
END SUB

'filter the engines to suit the chosen game
'=============================================================================
SUB Engines_Filter()
    'loop counter
    DIM i AS _UNSIGNED LONG
    
    'reset the short-list
    '(needed so that the user can go back and select a different game choice)
    LET Engines_ListCount = 0
    REDIM Engines_List(0) AS INTEGER
    
    'test each engine against the game's requirements:
    FOR i = 1 TO UBOUND(Engines)
        'are we looking for a specific engine-id?
        'e.g. the `/USE` command-line parameter
        IF CMD_USE$ <> "" THEN
            IF STRGET$(Engines(i).engine) <> LCASE$(CMD_USE$) THEN
                IF STRGET$(Engines(i).id) <> LCASE$(CMD_USE$) THEN
                    _CONTINUE
                END IF
            END IF
        END IF
        
        'does the engine support the type of IWAD given?
        IF (IWADs_Selected.type AND Engines(i).type) = 0 THEN _CONTINUE
        
        'is the binary compatible with this machine? (32 / 64-bit)
        'if we are a 32-bit machine, we can't run 64-bit software.
        'this has already been handling in Engine enumeration,
        'but I will leave this here for safety
        IF CPU_BIT = 32 AND Engines(i).bit = 64 THEN _CONTINUE
        
        'does the game demand a certain colour-depth? (i.e. software mode)
        IF Games_Selected.vid > 0 THEN
            'does the engine provide this colour depth?
            IF Engines(i).vid <> Games_Selected.vid THEN _CONTINUE
        END IF
        
        '---------------------------------------------------------------------
        
        'does this engine provide all the features required by the game?
        '(walk along the tags on the engine)
        FOR tag% = 1 TO UBOUND(Tags)
            'check the game's requirement for this tag
            SELECT CASE GameTags(Games_Current, tag%)
                'the *game* requires this from the engine
                CASE 1:
                    'if the *engine* does not provide this feature,
                    'move on to the next engine
                    IF EngineTags(i, tag%) = 0 THEN
                        '`_CONTINUE` does not support breaking nested loops
                        LET i = i + 1: GOTO NextEngine
                    END IF
            END SELECT
        NEXT tag%
        
        '---------------------------------------------------------------------
        
        'all requirements have been checked,
        'meaning that this engine is a candidate
        LET EngineTags(i, 0) = 1
        'add this engine to the valid short-list
        LET Engines_ListCount = Engines_ListCount + 1
        REDIM _PRESERVE Engines_List(1 TO Engines_ListCount) AS INTEGER
        LET Engines_List(Engines_ListCount) = i
        
    NextEngine:
    NEXT i

    IF Engines_ListCount = 0 THEN
        'TODO: we should do something useful here instead of erroring,
        'such as offering an open choice of engines
        CALL ErrorScreen("ERROR: No Compatible Engine Found")
        PRINTWRAP_X 2, UI_SCREEN_WIDTH - 2, _
            "No compatible engine could be found for the game / user " _
          + "requirements."
        CALL ErrorExit
    END IF
    
    '''print a list of the candidate engines:
    ''PRINT ""
    ''PRINT "Candidate Engines:"
    ''PRINT "------------------"
    ''FOR i = Engines_ListCount TO 1 STEP -1
    ''    PRINT "- " + STRGET$(Engines(Engines_List(i)).id) + ": " _
    ''        + STRGET$(Engines(Engines_List(i)).title), STRINT$(Engines(Engines_List(i)).type)
    ''    IF i MOD 24 = 0 THEN SLEEP
    ''NEXT i
    ''PRINT ""
    ''SLEEP
    
    'select the 'best' engine by default
    CALL Engines_Select(Engines_List(1))
END SUB

'============================================================================
SUB Engines_SelectTiers()
    'walk down the list of sort-listed engines and pick out the first
    'of each low, medium, and high-tiered engines
    
    'reset the results
    LET Engines_SelectedLow = 0
    LET Engines_SelectedMedium = 0
    LET Engines_SelectedHigh = 0
    
    'Engines_Filter must have been called,
    'or there will not be any engines to examine!
    IF Engines_ListCount = 0 THEN EXIT SUB
    
    DIM i AS LONG
    FOR i = Engines_ListCount TO 1 STEP - 1
        'which type of engine is this?
        SELECT CASE Engines(Engines_List(i)).tier
            CASE TIER_LOW: LET Engines_SelectedLow = Engines_List(i)
            CASE TIER_MEDIUM: LET Engines_SelectedMedium = Engines_List(i)
            CASE TIER_HIGH: LET Engines_SelectedHigh = Engines_List(i)
        END SELECT
    NEXT i
    
END SUB

'selects an engine for use, populating the 'selected engine' variables
'============================================================================
SUB Engines_Select(engine%)
    LET Engines_Current = engine%
    LET Engines_Selected = Engines(Engines_Current)
END SUB

'translates a comma-separated list of engine-types into a numeric value
'============================================================================
FUNCTION Engines_GetType%(type$)
    LET type$ = "," + UCASE$(type$) + ","
    
    IF INSTR(type$, ",DOOM,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM
    END IF
    IF INSTR(type$, ",DOOM2,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM2
    END IF
    IF INSTR(type$, ",HERETIC,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_HERETIC
    END IF
    IF INSTR(type$, ",HEXEN,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_HEXEN
    END IF
    IF INSTR(type$, ",STRIFE,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_STRIFE
    END IF
    IF INSTR(type$, ",CHEX,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_CHEX
    END IF
    IF INSTR(type$, ",DOOM64,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM64
    END IF
    
END FUNCTION

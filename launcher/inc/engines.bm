'copyright (C) Kroc Camen 2018, BSD 2-clause

'   Engines_Enumerate()
'   Engines_KinValue%(kin$*1)   -> INTEGER
'   Engines_Filter()
'   Engines_Select(engine%)
'   Engines_GetType%(type$)     -> INTEGER

'walk the ports folder and identify all engines present
'=============================================================================
SUB Engines_Enumerate()
    'loop counter
    DIM i AS _UNSIGNED LONG
    
    LET Engines_Count = 0
    
    'create a directory list in a file, containing only sub-folder names
    CHDIR DIR_EXE$ + "ports"
    SHELL _HIDE "DIR /AD /B > dir.tmp"
    
    DIM dir_handle%
    LET dir_handle% = FREEFILE
    OPEN "dir.tmp" FOR INPUT AS #dir_handle%
    
    DO WHILE EOF(dir_handle%) = FALSE
        'read a folder-name
        DIM dir$
        LINE INPUT #dir_handle%, dir$
        
        'check for an INI file in the engine's folder
        DIM ini_path$
        LET ini_path$ = _CWD$ + "\" + dir$ + "\porta-doom.ini"
        IF NOT _FILEEXISTS(ini_path$) THEN GOTO NextFolder
        
        'read the global values
        DIM ini_engine$
        LET ini_engine$ = ReadSetting$(ini_path$, "global", "engine")
        DIM ini_rank$
        LET ini_rank$ = ReadSetting$(ini_path$, "global", "rank")
        
        DIM ini_index%
        LET ini_index% = 1
        DO
            DIM ini_id$
            LET ini_id$ = ReadSetting$("", "engines", STRINT$(ini_index%))
            IF ini_id$ = "" THEN EXIT DO
            
            'increase the list of known engines
            LET Engines_Count = Engines_Count + 1
            REDIM _PRESERVE Engines(1 TO Engines_Count) AS Engine
            
            LET Engines(Engines_Count).engine = STRADD&(LCASE$(ini_engine$))
            LET Engines(Engines_Count).id = STRADD&(LCASE$(ini_id$))
            
            'read engine data from the INI file
            DIM ini_section$
            LET ini_section$ = "engine." + ini_id$
            
            DIM ini_title$
            LET ini_title$ = ReadSetting$("", ini_section$, "title")
            DIM ini_type$
            LET ini_type$ = ReadSetting$("", ini_section$, "type")
            DIM ini_exe$
            LET ini_exe$ = ReadSetting$("", ini_section$, "exe")
            DIM ini_ver$
            LET ini_ver$ = ReadSetting$("", ini_section$, "ver")
            DIM ini_bit$
            LET ini_bit$ = ReadSetting$("", ini_section$, "bit")
            DIM ini_vid$
            LET ini_vid$ = ReadSetting$("", ini_section$, "vid")
            DIM ini_kin$
            LET ini_kin$ = ReadSetting$("", ini_section$, "kin")
            DIM ini_cfg$
            LET ini_cfg$ = ReadSetting$("", ini_section$, "cfg")
            DIM ini_save$
            LET ini_save$ = ReadSetting$("", ini_section$, "save")
            DIM ini_tags$
            LET ini_tags$ = ReadSetting$("", ini_section$, "tags")
            DIM ini_auto$
            LET ini_auto$ = ReadSetting$("", ini_section$, "auto")
            DIM ini_cmd$
            LET ini_cmd$ = ReadSetting$("", ini_section$, "cmd")
            
            'executable architecture must be either 32 or 64-bit
            IF ini_bit$ <> "32" AND ini_bit$ <> "64" THEN
                'TODO: output warning?
                'default to 32-bit
                LET ini_bit$ = "32"
            END IF
            
            'process the tag list
            CALL Tags_Add(ini_tags$)
            
            LET Engines(Engines_Count).dir = STRADD&(dir$)
            LET Engines(Engines_Count).rank = VAL(ini_rank$)
            LET Engines(Engines_Count).title = STRADD&(ini_title$)
            LET Engines(Engines_Count).exe = STRADD&(ini_exe$)
            LET Engines(Engines_Count).ver = VAL(ini_ver$)
            LET Engines(Engines_Count).bit = VAL(ini_bit$)
            LET Engines(Engines_Count).vid = VAL(ini_vid$)
            SELECT CASE ini_kin$
                CASE "X": LET Engines(Engines_Count).kin = KIN_X
                CASE "V": LET Engines(Engines_Count).kin = KIN_V
                CASE "B": LET Engines(Engines_Count).kin = KIN_B
                CASE "Z": LET Engines(Engines_Count).kin = KIN_Z
                CASE "G": LET Engines(Engines_Count).kin = KIN_G
                CASE ELSE
                    LET Engines(Engines_Count).kin = 0
            END SELECT
            LET Engines(Engines_Count).cfg = STRADD&(ini_cfg$)
            LET Engines(Engines_Count).save = STRADD&(ini_save$)
            LET Engines(Engines_Count).tags = STRADD&(ini_tags$)
            LET Engines(Engines_Count).auto = STRADD&(ini_auto$)
            LET Engines(Engines_Count).cmd = STRADD&(ini_cmd$)
            
            LET ini_index% = ini_index% + 1
        LOOP
    NextFolder:
    LOOP
    
    CLOSE #dir_handle%
    KILL "dir.tmp"
    CHDIR DIR_EXE$
    
    'prioritise engine list:
    '-------------------------------------------------------------------------
    '... given ten different versions of GZDoom, each with hardware/software
    'renderers, which is the 'best' that we should default to?
    
    'the criteria for the 'best' engine is:
    '- prefer engines with a higher rank
    '- prefer engines in a higher genealogy, i.e. "G" > "Z" > "B" > "V"
    '- prefer newer versions over older versions
    '- prefer hardware renderers (if present) over software
    '- prefer 64-bit (if present and machine supports it) over 32-bit
    
    'to whit, re-order the list of engines according to this criteria:
    
    DIM sorted%
    LET sorted% = FALSE
    DIM sortCount%
    
    DO WHILE sorted% = FALSE
        LET sorted% = TRUE
        
        FOR i = 2 TO Engines_Count
            'compare the engine with the one above
            '(A = above, B = below)
            DIM A%, B%
            LET A% = i - 1
            LET B% = i
            
            'compare the engine's rank:
            DIM rA%, rB%
            LET rA% = Engines(A%).rank
            LET rB% = Engines(B%).rank
            
            'if the engine below is of a higher rank, move it up
            IF rB% > rA% THEN
                SWAP Engines(A%), Engines(B%)
                LET sortCount% = sortCount% + 1
                LET sorted% = FALSE
                
            ELSEIF rB% = rA% THEN
                'compare the two engine's genealogy:
                DIM kA%, kB%
                LET kA% = Engines(A%).kin
                LET kB% = Engines(B%).kin
                
                'if the engine below is of a higher genealogy, move it up
                IF kB% > kA% THEN
                    SWAP Engines(A%), Engines(B%)
                    LET sortCount% = sortCount% + 1
                    LET sorted% = FALSE
                
                ELSEIF kB% = kA% THEN
                    'compare the names (alphabetically sort engines)
                    DIM nA$, nB$
                    LET nA$ = STRGET$(Engines(A%).engine)
                    LET nB$ = STRGET$(Engines(B%).engine)
                    
                    IF nB$ < nA$ THEN
                        SWAP Engines(A%), Engines(B%)
                        LET sortCount% = sortCount% + 1
                        LET sorted% = FALSE
                    
                    ELSEIF nB$ = nA$ THEN
                        'compare the two engine's version numbers
                        DIM vA%, vB%
                        LET vA% = Engines(A%).ver
                        LET vB% = Engines(B%).ver
                        
                        IF vB% > vA% THEN
                            SWAP Engines(A%), Engines(B%)
                            LET sortCount% = sortCount% + 1
                            LET sorted% = FALSE
                            
                        ELSEIF vB% = vA% THEN
                            'compare renderer colour-depth
                            DIM cA%, cB%
                            LET cA% = Engines(A%).vid
                            LET cB% = Engines(B%).vid
                            
                            IF cB% > cA% THEN
                                SWAP Engines(A%), Engines(B%)
                                LET sortCount% = sortCount% + 1
                                LET sorted% = FALSE
                            
                            ELSEIF cB% = cA% THEN
                                'compare executable CPU-type (32/64-bit)
                                DIM xA%, xB%
                                LET xA% = Engines(A%).bit
                                LET xB% = Engines(B%).bit
                                
                                IF xB% > xA% THEN
                                    SWAP Engines(A%), Engines(B%)
                                    LET sortCount% = sortCount% + 1
                                    LET sorted% = FALSE
                                END IF
                            END IF
                            
                        END IF
                    END IF
                END IF
            END IF
        NEXT i
        
    LOOP
    
    '-------------------------------------------------------------------------
    
    'create a look-up table of which engines provide which tags
    REDIM EngineTags(1 TO Engines_Count, 0 TO UBOUND(Tags)) AS LONG
    FOR i = 1 TO UBOUND(Engines)
        LET tag$ = Tags_Split$(STRGET$(Engines(i).tags))
        DO WHILE tag$ <> ""
            'find the tag index
            LET tag% = Tags_Find%(tag$)
            'set up the game <> tag mapping
            LET EngineTags(i, tag%) = 1
            'get the next tag in the list
            LET tag$ = Tags_Split$("")
        LOOP
    NEXT i
    
    'also, do this for game definitions -- this has to be done after
    'enumerating the engines, as all unique tags will be known by then
    REDIM GameTags(1 TO Games_Count, 1 TO UBOUND(Tags)) AS LONG
    FOR i = 1 TO UBOUND(Games)
        LET tag$ = Tags_Split$(STRGET$(Games(i).tags))
        DO WHILE tag$ <> ""
            'find the tag index
            LET tag% = Tags_Find%(tag$)
            'set up the game <> tag mapping
            LET GameTags(i, tag%) = 1
            'get the next tag in the list
            LET tag$ = Tags_Split$("")
        LOOP
    NEXT i
    
END SUB

'filter the engines to suit the chosen game
'=============================================================================
SUB Engines_Filter()
    'loop counter
    DIM i AS _UNSIGNED LONG
    
    'test each engine against the game's requirements:
    FOR i = 1 TO UBOUND(Engines)
        'are we looking for a specific engine-id?
        'e.g. the `/USE` command-line parameter
        IF CMD_USE$ <> "" THEN
            IF STRGET$(Engines(i).engine) <> LCASE$(CMD_USE$) THEN
                IF STRGET$(Engines(i).id) <> LCASE$(CMD_USE$) THEN
                    _CONTINUE
                END IF
            END IF
        END IF
        
        'is the binary compatible with this machine? (32 / 64-bit)
        'if we are a 32-bit machine, we can't run 64-bit software
        IF CPU_BIT = 32 AND Engines(i).bit = 64 THEN
            _CONTINUE
        END IF
        
        'does the game demand a certain colour-depth? (i.e. software mode)
        IF Games_Selected.vid > 0 THEN
            'does the engine provide this colour depth?
            IF Engines(i).vid <> Games_Selected.vid THEN _CONTINUE
        END IF
        
        '---------------------------------------------------------------------
        
        'does this engine provide all the features required by the game?
        '(walk along the tags on the engine)
        FOR tag% = 1 TO UBOUND(Tags)
            'check the game's requirement for this tag
            SELECT CASE GameTags(Games_Current, tag%)
                'the *game* requires this from the engine
                CASE 1:
                    'if the *engine* does not provide this feature,
                    'move on to the next engine
                    IF EngineTags(i, tag%) = 0 THEN
                        '`_CONTINUE` does not support breaking nested loops
                        LET i = i + 1: GOTO NextEngine
                    END IF
            END SELECT
        NEXT tag%
        
        '---------------------------------------------------------------------
        
        'all tags have been checked, meaning that this engine is a candidate
        LET EngineTags(i, 0) = 1
        'add this tag to the valid short-list
        LET Engines_ListCount = Engines_ListCount + 1
        REDIM _PRESERVE Engines_List(1 TO Engines_ListCount) AS INTEGER
        LET Engines_List(Engines_ListCount) = i
        
    NextEngine:
    NEXT i

    IF Engines_ListCount = 0 THEN
        PRINT " ERROR: NO ENGINE FOUND!"
        SLEEP
        SYSTEM 1
    END IF
    
    'print a list of the candidate engines:
    ''PRINT ""
    ''PRINT "Candidate Engines:"
    ''PRINT "------------------"
    ''FOR i = 1 TO Engines_ListCount
    ''    PRINT "- " + STRGET$(Engines(Engines_List(i)).id) + ": " _
    ''        + STRGET$(Engines(Engines_List(i)).title)
    ''NEXT i
    ''PRINT ""
    
    'select the 'best' engine by default
    CALL Engines_Select(Engines_List(1))
END SUB

'selects an engine for use, populating the 'selected engine' variables
'============================================================================
SUB Engines_Select(engine%)
    LET Engines_Current = engine%
    LET Engines_Selected = Engines(Engines_Current)
END SUB

'translates a comma-separated list of engine-types into a numeric value
'============================================================================
FUNCTION Engines_GetType%(type$)
    LET type$ = "," + UCASE$(type$) + ","
    
    IF INSTR(type$, ",DOOM,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM
    END IF
    IF INSTR(type$, ",DOOM2,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM2
    END IF
    IF INSTR(type$, ",HERETIC,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_HERETIC
    END IF
    IF INSTR(type$, ",HEXEN,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_HEXEN
    END IF
    IF INSTR(type$, ",STRIFE,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_STRIFE
    END IF
    IF INSTR(type$, ",DOOM64,") THEN
        LET Engines_GetType% = Engines_GetType% OR TYPE_DOOM64
    END IF
    
END FUNCTION

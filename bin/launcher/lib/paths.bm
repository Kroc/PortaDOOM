'copyright (C) Kroc Camen 2018, BSD 2-clause

'is the path absolute? i.e. "\..." or "C:\..."
'=============================================================================
FUNCTION Paths.IsAbsolute(path$)
    'just in case we're passed a fixed-length string
    LET path$ = RTRIM$(path$)
    'don't be silly
    IF LEN(path$) = 0 THEN EXIT FUNCTION
    
    'begins with a slash?
    IF ASC(path$, 1) = ASC_BSLASH THEN
        LET Paths.IsAbsolute = TRUE
    
    'we don't want to check the 2nd character if there isn't one.
    'since here it's not a slash, the path cannot be absolute
    ELSEIF LEN(path$) < 2 THEN
        EXIT FUNCTION
        
    'check the 2nd character for ":", e.g. "C:"
    ELSEIF ASC(path$, 2) = ASC_COLON THEN
        LET Paths.IsAbsolute = TRUE
        
    END IF
END FUNCTION

'if there isn't, adds a slash to the end of a string
'=============================================================================
FUNCTION Paths.AddSlash$(path$)
    'just in case we're passed a fixed-length string
    LET path$ = RTRIM$(path$)
    
    IF LEN(path$) = 0 THEN
        LET Paths.AddSlash$ = "\"
    
    ELSEIF ASC(path$, LEN(path$)) <> ASC_BSLASH THEN
        LET Paths.AddSlash$ = path$ + "\"
        
    ELSE
        LET Paths.AddSlash$ = path$
    END IF
END FUNCTION

'return the folder name from a path
'=============================================================================
FUNCTION Paths.GetFolderName$(path$)
    'just in case we're passed a fixed-length string
    LET path$ = RTRIM$(path$)
    'don't be silly
    IF LEN(path$) = 0 THEN EXIT FUNCTION
    IF path$ = "\" THEN EXIT FUNCTION
    
    'return nothing if there's no slash at all, i.e. the string is just a
    'file-name. directories MUST end with slash; use `Paths.AddSlash$` to
    'ensure a directory is always terminated correctly
    IF INSTR(path$, "\") = 0 THEN EXIT FUNCTION
    
    DIM a AS _UNSIGNED LONG
    DIM z AS _UNSIGNED LONG
    DIM len_path AS _UNSIGNED LONG
    LET len_path = LEN(path$)
    
    'this assumes that a folder always ends with a slash, otherwise it's
    'a file name. is the last character is already a slash?
    IF ASC(path$, len_path) = ASC_BSLASH THEN
        'we know the end position already,
        'skip over to finding the beginning
        LET z = len_path
    ELSE
        'walk backward through the string looking for the slash;
        'due to the validation check at the beginning of the function,
        'we know for certain at least one back-slash exists
        FOR z = len_path TO 1 STEP - 1
            IF ASC(path$, z) = ASC_BSLASH THEN EXIT FOR
        NEXT z
    END IF
    
    'we've passed the file name, walk backwards to capture the folder name
    FOR a = z - 1 TO 0 STEP - 1
        IF a = 0 THEN EXIT FOR
        IF ASC(path$, a) = ASC_BSLASH THEN EXIT FOR
    NEXT a
    
    'if an earlier slash was not found,
    'then there was only one folder, e.g. "some_folder\some.file"
    IF a = 0 THEN
        LET Paths.GetFolderName$ = LEFT$(path$, z - 1)
    ELSE
        'extract the folder name from the boundaries we determined
        LET Paths.GetFolderName$ = MID$(path$, a + 1, z - a - 1)
    END IF
END FUNCTION

'returns the file name (including extension) from a path
'=============================================================================
FUNCTION Paths.GetFileName$(path$)
    'just in case we're passed a fixed-length string
    LET path$ = RTRIM$(path$)
    
    DIM len_path AS _UNSIGNED LONG
    LET len_path = LEN(path$)
    
    'don't be silly
    IF len_path = 0 THEN EXIT FUNCTION
    'if the path ends in a slash then it's a folder and there's no file-name
    IF ASC(path$, len_path) = ASC_BSLASH THEN EXIT FUNCTION
    
    'return the input if there's no slash at all, i.e. the string is just a
    'file-name. directories MUST end with slash; use `Paths.AddSlash$` to
    'ensure a directory is always terminated correctly
    IF INSTR(path$, "\") = 0 THEN
        LET Paths.GetFileName$ = path$
        EXIT FUNCTION
    END IF
    
    'walk backward through the string looking for the slash;
    'due to the validation check at the beginning of the function,
    'we know for certain at least one back-slash exists
    DIM i AS _UNSIGNED LONG
    FOR i = len_path TO 1 STEP - 1
        IF ASC(path$, i) = ASC_BSLASH THEN EXIT FOR
    NEXT i
    
    'the file name is from the last slash, forward
    LET Paths.GetFileName$ = RIGHT$(path$, len_path - i)
END FUNCTION

'returns the file name (excluding extension) from a path
'=============================================================================
FUNCTION Paths.GetFileBaseName$(path$)
    'just in case we're passed a fixed-length string
    LET path$ = RTRIM$(path$)
    
    DIM len_path AS _UNSIGNED LONG
    LET len_path = LEN(path$)
    
    'don't be silly
    IF len_path = 0 THEN EXIT FUNCTION
    'if the path ends in a slash then it's a folder and there's no file-name
    IF ASC(path$, len_path) = ASC_BSLASH THEN EXIT FUNCTION
    
    'walk backward through the string looking for a slash since we only want
    'the name from that point forward. if there is no slash, we'll take the
    'name as from the start of the string
    DIM a AS _UNSIGNED LONG
    FOR a = len_path - 1 TO 1 STEP - 1
        IF ASC(path$, a) = ASC_BSLASH THEN EXIT FOR
    NEXT a
    'this is a beautiful bit of serendipity: if the slash is found, then we
    'want to start the file name after the slash, and if the slash is not
    'found then the final `NEXT` ensures that the value of A is 0 and we
    'want it to be 1 (first character)
    LET a = a + 1
    
    'now walk forward looking for the dot
    DIM z AS _UNSIGNED LONG
    FOR z = a TO len_path
        IF ASC(path$, z) = ASC_PERIOD THEN EXIT FOR
    NEXT z
    LET z = z - 1
    
    'slice out the string we want
    LET Paths.GetFileBaseName$ = MID$(path$, a, z)
END FUNCTION
